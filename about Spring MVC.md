# About Spring MVC
 
1) DispatcherServlet
 - 가장 앞서 요청을 받아들이기 때문에 Front Controller라고 불림
 - 스프링 프레임워크의 중심이 되는 서블릿, 클라이언트의 모든 요청을 받아 흐름을 제어
 - 각 컨트롤러에 요청을 전달하고 컨트롤러가 반환한 결과값을 View에 전달하여 응답
 - web.xml에 정의되어 있으며, 보통 servlet-context.xml 설정 파일을 읽어 컨테이너를 구동
 
2) HandlerMapping
 - 클라이언트의 요청 URL을 처리할 컨트롤러를 결정해 DispatcherServlet에 반환
 - @Controller 어노테이션이 적용된 객체의 @RequestMapping 값을 이용해 요청을 처리할 컨트롤러 탐색
 
3) HandlerAdapter
 - DispatcherServlet의 처리 요청을 변환해서 컨트롤러에게 전달
 - 컨트롤러의 응답 결과를 DispatcherServlet이 요구하는 형식으로 변환
 
4) Controller
 - 실제 클라이언트의 요청을 처리한 뒤, 처리 결과를 void, String, ModelAndView 형태로 반환
 - GET, POST 방식 등 전송 방식에 대한 처리를 어노테이션으로 처리
 
5) ViewResolver
 - 컨트롤러의 처리 결과를 보여줄 뷰를 결정

# 스프링 MVC가 처리해주는 작업
 - URI를 분석해서 적절한 컨트롤러를 결정
 - 컨트롤러에 필요한 메소드를 호출
 - 컨트롤러의 결과 데이터를 뷰로 전달
 - 처리 결과를 보여줄 적절한 뷰를 결정
 
# 개발자가 직접 해야하는 작업
 - 특정 URI에 동작하는 컨트롤러를 설계
 - 컨트롤러 내에 원하는 결과를 메서드로 설계
 - 서비스 객체의 생성
 - DAO 객체의 생성(Mybatis 사용시 X)
 - 뷰에서 전달받은 데이터의 출력

## Maven Dependency(?)
 - 스프링 MVC 사용시 JSP/Servlet 버전을 상향시킬 필요가 있음
 
================================================================
# 스프링 MVC 구현 방법

1) 컨트롤러 설계/구현
 - @Controller어노테이션을 클래스에 적용
 - @RequestMapping 어노테이션을 이용해서 처리할 요청 경로 지정
 - 클라이언트의 요청을 처리할 메서드를 구현하고, 뷰 이름 리턴
 - 리턴시 Redirect 형식으로 리턴한다면 다시 컨트롤러로 요청
 
2) 컨트롤러 - @RequestMapping 어노테이션
 - 리턴타입에 따른 경로 변경
 - RequestMapping 요청 방식 (GET, POST)
================================================================

## DTO/VO 객체를 이용
 - 폼데이터의 이름과 동일한 필드명을 가진 DTO/VO 객체를 이용해 데이터 처리 가능
 - 알아서 Getter / Setter 메서드를 이용해 데이터를 처리하기 때문에 가장 많이 사용되는 방법이다.
 - DTO/VO를 이용할 경우 컨트롤러 뿐 아니라 이후 보내지는 jsp페이지까지 데이터가 유효하다.
 
 % DTO/VO객체를 이용하여 데이터를 처리할 때 주의할 점이 있다.
 컨트롤러 이후 jsp 페이지로 객체가 보내질 때 객체의 이름은 클래스이름의 맨 앞 대문자만 소문자로 대치된 이름으로
 객체가 넘어가게 된다. @ModelAttribute 라는 어노테이션으로 보내지는 객체의 이름을 변경할 수 있다.
 
 
 
 